{
    "ROS2: Node-Klasse mit main()-Block und Fehlerbehandlung": {
        "prefix": "ros_main_class",
        "body": [
        "from rclpy.node import Node",
        "import rclpy",
        "",
        "class ${1:MyNodeClass}(Node):",
        "    def __init__(self, node_name: str):",
        "        super().__init__(node_name)",
        "",
        "    def destroy_node(self):",
        "        return super().destroy_node()",
        "",
        "def main():",
        "    node = None",
        "    try:",
        "        rclpy.init()",
        "        try:",
        "            node = ${1:MyNodeClass}(\"${2:node_name}\")",
        "        except Exception as e:",
        "            print(f\"Fehler beim Erstellen des Nodes: {e}\")",
        "            return",
        "",
        "        rclpy.spin(node)",
        "",
        "    except KeyboardInterrupt:",
        "        print(\"Sie haben STRG+C gedr√ºckt!\")",
        "",
        "    finally:",
        "        if node is not None:",
        "            if rclpy.ok():",
        "                node.get_logger().info(f\"Node {node.get_name()} wird beendet!\")",
        "            node.destroy_node()",
        "        if rclpy.ok():",
        "            rclpy.shutdown()",
        "",
        "if __name__ == \"__main__\":",
        "    main()"
        ],
        "description": "ROS2 Node-Klasse mit einem main()-Block, Fehlerbehandlung und sicherem Shutdown"
    },

    "ROS2 Node Import Template":{
        "prefix": "ros_node_import",
        "body": [
            "import rclpy",
            "from rclpy.node import Node",
            "from std_msgs.msg import String, Float32",
            "from sensor_msgs.msg import Image",
            "from geometry_msgs.msg import Twist",
        ],
        "description": "ROS2 Template f√ºr Imports bei Nodes"

    },

    "ROS2 Publisher Template": {
        "prefix": "ros_pub",
        "body": [
        "self._pub_${1:arg_name} = self.create_publisher(${2:arg_msg_type}, '/${1:arg_name}', 10)"
        ],
        "description": "ROS2 Publisher mit _pub Prefix und Topic = /arg_name"
    },


    "ROS2 Subscriber Template": {
        "prefix": "ros_sub",
        "body": [
        "self._sub_${1:arg_name} = self.create_subscription(",
        "    ${2:arg_msg_type},",
        "    '/${1:arg_name}',",
        "    self._sub_${1:arg_name}_cb,",
        "    10",
        ")"
        ],
        "description": "ROS2 Subscriber mit _sub Prefix, Topic = /arg_name und Callback"
    },

           
    // üîÄ Launch-Datei mit Argumenten (komplettes Beispiel)
    "ROS2 Launch Dummy": {
        "prefix": "ros_launch_file",
        "body": [
            "from launch import LaunchDescription",
            "from launch.actions import DeclareLaunchArgument",
            "from launch.substitutions import LaunchConfiguration",
            "from launch_ros.actions import Node",
            "from ament_index_python.packages import get_package_share_directory",
            "",
            "def generate_launch_description():",
            "    arg_value = DeclareLaunchArgument('dummy_arg', default_value='42', description='Dummy Argument')",
            "",
            "    node = Node(",
            "        package='demo_pkg',",
            "        executable='demo_node',",
            "        name='demo_node',",
            "        parameters=[{",
            "            'dummy_param': LaunchConfiguration('dummy_arg')",
            "        }]",
            "    )",
            "",
            "    ld = LaunchDescription()",
            "    ld.add_action(arg_value)",
            "    ld.add_action(node)",
            "    return ld"
        ],
        "description": "Minimaler ROS2 Launch mit einem Argument und einem Node"
    },

    // üì¶ Basis-Importe f√ºr ROS2-Launch-Dateien
    "ROS2 Launch: Import Statements": {
        "prefix": "ros_launch_file_empty",
        "body": [
            "from launch import LaunchDescription",
            "from launch.actions import DeclareLaunchArgument",
            "from launch.substitutions import LaunchConfiguration",
            "from launch_ros.actions import Node",
            "from ament_index_python.packages import get_package_share_directory",
            "",
            "def generate_launch_description():",
            "    return ld"
        ],
        "description": "Importe f√ºr ROS2-Launch-Dateien"
    },
    
    // üß± Deklariert ein einzelnes Launch-Argument
    "ROS2 Launch: Declare Argument": {
        "prefix": "ros_launch_arg",
        "body": [
        "DeclareLaunchArgument(",
        "    '${1:arg_name}',",
        "    default_value='${2:default}',",
        "    description='${3:Beschreibung}'",
        ")"
        ],
        "description": "Deklariert ein Launch-Argument"
    },
    
    
    // ‚öôÔ∏è Node mit Parametern
    "ROS2 Launch: Node mit Parametern": {
        "prefix": "ros_launch_node_param",
        "body": [
        "Node(",
        "    package='${1:mein_paket}',",
        "    executable='${2:mein_knoten}',",
        "    name='${3:knoten_name}',",
        "    parameters=[{",
        "        '${4:param_name}': ${5:Wert}",
        "    }],",
        "    output='screen'",
        ")"
        ],
        "description": "ROS2 Node mit Parametern"
    },   

    "Include Launch Description": {
        "prefix": "ros_launch_ld",
        "body": [
        "ld_${1:name} = IncludeLaunchDescription(",
        "    PythonLaunchDescriptionSource([",
        "        os.path.join(",
        "            get_package_share_directory(\"${2:package_name}\"),",
        "            \"launch\",",
        "            \"${3:launch_file}.launch.py\"",
        "        )",
        "    ])",
        ")"
        ],
        "description": "Include a launch description with placeholders for package and launch file"
    },

    "CMakeLists: Include RIDL": {
        "prefix": "ros_cmake_ridl",
        "body": [
            "find_package(rosidl_default_generators REQUIRED)",
            "",
            "rosidl_generate_interfaces(\\${PROJECT_NAME}",
            "\"srv/MeinInterface.srv\"",
            ")",
            "",
            "ament_export_dependencies(rosidl_default_runtime)",
        ],
        "description": "Erweiterung in CMAKE zum Bauen von Interfaces mit RIDL"
    },

    "package_xml: Include RIDL": {
        "prefix": "ros_package_xml_ridl",
        "body": [
            "  <buildtool_depend>rosidl_default_generators</buildtool_depend>",
            "  <exec_depend>rosidl_default_runtime</exec_depend>",
            "  <member_of_group>rosidl_interface_packages</member_of_group>",
        ],
        "description": "Erweiterung in package.xml zum Bauen von Interfaces mit RIDL"
    },

    "ROS2 StateMachine Base": {
    "prefix": "ros_sm_base",
    "description": "Basisklassen State und StateMachine f√ºr ROS2-Zustandsautomat",
    "body": [
      "from __future__ import annotations",
      "from abc import ABC, abstractmethod",
      "",
      "",
      "class State(ABC):",
      "    \"\"\"Basisklasse f√ºr alle Zust√§nde der State-Machine.\"\"\"",
      "",
      "    def __init__(self, name: str) -> None:",
      "        self.name = name",
      "",
      "    def on_enter(self, node) -> None:",
      "        \"\"\"Wird einmalig beim Eintritt in den Zustand ausgef√ºhrt.\"\"\"",
      "        pass",
      "",
      "    def on_exit(self, node) -> None:",
      "        \"\"\"Wird einmalig beim Verlassen des Zustands ausgef√ºhrt.\"\"\"",
      "        pass",
      "",
      "    @abstractmethod",
      "    def tick(self, node) -> str | None:",
      "        \"\"\"",
      "        Wird zyklisch aufgerufen.",
      "        Muss entweder None (im Zustand bleiben)",
      "        oder den Namen des n√§chsten States zur√ºckgeben.",
      "        \"\"\"",
      "        ...",
      "",
      "",
      "class StateMachine:",
      "    \"\"\"Verwalten der States + Ablaufsteuerung.\"\"\"",
      "",
      "    def __init__(self, node) -> None:",
      "        self._node = node",
      "        self._states: dict[str, State] = {}",
      "        self._current_state: State | None = None",
      "",
      "    def add_state(self, state: State) -> None:",
      "        self._states[state.name] = state",
      "",
      "    def set_initial_state(self, name: str) -> None:",
      "        self._current_state = self._states[name]",
      "        self._node.get_logger().info(f\"Initialer Zustand: {name}\")",
      "        self._current_state.on_enter(self._node)",
      "",
      "    def step(self) -> None:",
      "        \"\"\"Soll aus dem ROS2-Timer aufgerufen werden.\"\"\"",
      "        if self._current_state is None:",
      "            return",
      "",
      "        next_name = self._current_state.tick(self._node)",
      "",
      "        if next_name is not None and next_name != self._current_state.name:",
      "            # Ausgangsaktion",
      "            self._current_state.on_exit(self._node)",
      "",
      "            old = self._current_state.name",
      "            self._current_state = self._states[next_name]",
      "",
      "            self._node.get_logger().info(",
      "                f\"Zustandswechsel: {old} ‚Üí {next_name}\"",
      "            )",
      "",
      "            # Eingangsaktion",
      "            self._current_state.on_enter(self._node)"
    ]
  },
  "ROS2 StateMachine State": {
    "prefix": "ros_sm_state",
    "description": "Vorlage f√ºr einen ROS2-State (Datei im states-Ordner)",
    "body": [
      "from __future__ import annotations",
      "# Den nachfolgenden Import eventuell anpassen!",
      "from ..state_machine import State",
      "",
      "",
      "class ${1:MyNewState}(State):",
      "    \"\"\"${2:Beschreibung des States}\"\"\"",
      "",
      "    def __init__(self) -> None:",
      "        super().__init__(\"${3:MY_NEW_STATE}\")",
      "",
      "    def on_enter(self, node) -> None:",
      "        node.get_logger().info(\"ENTER ${3:MY_NEW_STATE}\")",
      "",
      "    def tick(self, node) -> str | None:",
      "        node.get_logger().info(\"TICK ${3:MY_NEW_STATE}\")",
      "",
      "        # TODO: √úbergangsbedingung anpassen",
      "        if self._counter > 10:",
      "            return \"${4:NEXT_STATE}\"",
      "",
      "        return None",
      "",
      "    def on_exit(self, node) -> None:",
      "        node.get_logger().info(\"EXIT ${3:MY_NEW_STATE}\")"
    ]
  },
  "ROS2 Qt GUI Node": {
    "prefix": "ros_qt_gui_node",
    "description": "ROS2 Node + Qt GUI with spin thread (custom class names)",
    "body": [
      "import sys",
      "import threading",
      "",
      "import rclpy",
      "from rclpy.node import Node",
      "from rclpy.executors import SingleThreadedExecutor",
      "",
      "from PyQt5 import QtCore, QtGui, QtWidgets",
      "",
      "class ${1:MyROSNode}(Node):",
      "    def __init__(self, node_name: str):",
      "        super().__init__(node_name)",
      "",
      "    def destroy_node(self):",
      "        return super().destroy_node()",
      "",
      "",
      "class ${2:MyGUI}(QtWidgets.QWidget):",
      "    \"\"\"",
      "    Qt-GUI",
      "    \"\"\"",
      "",
      "    def __init__(self, node: ${1:MyROSNode}):",
      "        super().__init__()",
      "        self.node = node",
      "",
      "        self.setWindowTitle(\"Empty GUI\")",
      "        self.resize(400, 100)",
      "",
      "        self.btn_quit = QtWidgets.QPushButton(\"Beenden\")",
      "        self.btn_dummy = QtWidgets.QPushButton(\"Klick mich\")",
      "",
      "        layout_button = QtWidgets.QVBoxLayout()",
      "        layout_button.addWidget(self.btn_dummy)",
      "        layout_button.addWidget(self.btn_quit)",
      "",
      "        self.setLayout(layout_button)",
      "",
      "        self.btn_dummy.clicked.connect(self.on_dummy_clicked)",
      "        self.btn_quit.clicked.connect(self.close)",
      "",
      "    def on_dummy_clicked(self):",
      "        \"\"\"Dummy-Button gedr√ºckt.\"\"\"",
      "        self.node.get_logger().info(\"Dummy-Button gedr√ºckt!\")",
      "        msgbox = QtWidgets.QMessageBox(self)",
      "        msgbox.setWindowTitle(\"Dummy\")",
      "        msgbox.setText(\"Du hast mich geklickt!\")",
      "        msgbox.show()",
      "",
      "    def closeEvent(self, event):",
      "        if rclpy.ok():",
      "            self.node.get_logger().info(\"GUI wird geschlossen, ROS wird heruntergefahren...\")",
      "            rclpy.shutdown()",
      "        event.accept()",
      "",
      "",
      "def main():",
      "    node = None",
      "    executor = None",
      "    spin_thread = None",
      "",
      "    try:",
      "        rclpy.init()",
      "",
      "        node = ${1:MyROSNode}(\"${3:my_gui_node}\")",
      "        executor = SingleThreadedExecutor()",
      "        executor.add_node(node)",
      "",
      "        # Thread-Funktion f√ºr ROS-Spin",
      "        def ros_spin():",
      "            try:",
      "                executor.spin()",
      "            finally:",
      "                executor.shutdown()",
      "                node.destroy_node()",
      "",
      "        # Hintergrund-Thread starten",
      "        spin_thread = threading.Thread(target=ros_spin, daemon=True)",
      "        spin_thread.start()",
      "",
      "        # Qt-App im Hauptthread laufen lassen",
      "        app = QtWidgets.QApplication(sys.argv)",
      "        window = ${2:MyGUI}(node)",
      "        window.show()",
      "        exit_code = app.exec_()",
      "",
      "        # Wenn Qt beendet ‚Üí sicherstellen, dass ROS auch aus ist",
      "        if rclpy.ok():",
      "            rclpy.shutdown()",
      "",
      "        # Auf Thread warten (kurz)",
      "        if spin_thread.is_alive():",
      "            spin_thread.join(timeout=1.0)",
      "",
      "        sys.exit(exit_code)",
      "",
      "    except KeyboardInterrupt:",
      "        print(\"STRG+C gedr√ºckt\")",
      "        if rclpy.ok():",
      "            rclpy.shutdown()",
      "",
      "    finally:",
      "        if executor is not None:",
      "            executor.shutdown()",
      "        if node is not None:",
      "            try:",
      "                node.destroy_node()",
      "            except Exception:",
      "                pass",
      "        if rclpy.ok():",
      "            rclpy.shutdown()",
      "",
      "if __name__ == \"__main__\":",
      "    main()"
    ]
  }
}
