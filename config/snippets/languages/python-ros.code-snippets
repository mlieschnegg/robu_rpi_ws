{
    "ROS2: Node-Klasse mit main()-Block und Fehlerbehandlung": {
        "prefix": "ros_main_class",
        "body": [
        "from rclpy.node import Node",
        "import rclpy",
        "",
        "class ${1:MyNodeClass}(Node):",
        "    def __init__(self, node_name: str):",
        "        super().__init__(node_name)",
        "",
        "    def destroy_node(self):",
        "        return super().destroy_node()",
        "",
        "def main():",
        "    node = None",
        "    try:",
        "        rclpy.init()",
        "        try:",
        "            node = ${1:MyNodeClass}(\"${2:node_name}\")",
        "        except Exception as e:",
        "            print(f\"Fehler beim Erstellen des Nodes: {e}\")",
        "            return",
        "",
        "        rclpy.spin(node)",
        "",
        "    except KeyboardInterrupt:",
        "        print(\"Sie haben STRG+C gedr√ºckt!\")",
        "",
        "    finally:",
        "        if node is not None:",
        "            if rclpy.ok():",
        "                node.get_logger().info(f\"Node {node.get_name()} wird beendet!\")",
        "            node.destroy_node()",
        "        if rclpy.ok():",
        "            rclpy.shutdown()",
        "",
        "if __name__ == \"__main__\":",
        "    main()"
        ],
        "description": "ROS2 Node-Klasse mit einem main()-Block, Fehlerbehandlung und sicherem Shutdown"
    },

    "ROS2 Node Import Template":{
        "prefix": "ros_node_import",
        "body": [
            "import rclpy",
            "from rclpy.node import Node",
            "from std_msgs.msg import String, Float32",
            "from sensor_msgs.msg import Image",
            "from geometry_msgs.msg import Twist",
        ],
        "description": "ROS2 Template f√ºr Imports bei Nodes"

    },

    "ROS2 Publisher Template": {
        "prefix": "ros_pub",
        "body": [
        "self._pub_${1:arg_name} = self.create_publisher(${2:arg_msg_type}, '/${1:arg_name}', 10)"
        ],
        "description": "ROS2 Publisher mit _pub Prefix und Topic = /arg_name"
    },


    "ROS2 Subscriber Template": {
        "prefix": "ros_sub",
        "body": [
        "self._sub_${1:arg_name} = self.create_subscription(",
        "    ${2:arg_msg_type},",
        "    '/${1:arg_name}',",
        "    self._sub_${1:arg_name}_cb,",
        "    10",
        ")"
        ],
        "description": "ROS2 Subscriber mit _sub Prefix, Topic = /arg_name und Callback"
    },

           
    // üîÄ Launch-Datei mit Argumenten (komplettes Beispiel)
    "ROS2 Launch Dummy": {
        "prefix": "ros_launch_file",
        "body": [
            "from launch import LaunchDescription",
            "from launch.actions import DeclareLaunchArgument",
            "from launch.substitutions import LaunchConfiguration",
            "from launch_ros.actions import Node",
            "from ament_index_python.packages import get_package_share_directory",
            "",
            "def generate_launch_description():",
            "    arg_value = DeclareLaunchArgument('dummy_arg', default_value='42', description='Dummy Argument')",
            "",
            "    node = Node(",
            "        package='demo_pkg',",
            "        executable='demo_node',",
            "        name='demo_node',",
            "        parameters=[{",
            "            'dummy_param': LaunchConfiguration('dummy_arg')",
            "        }]",
            "    )",
            "",
            "    ld = LaunchDescription()",
            "    ld.add_action(arg_value)",
            "    ld.add_action(node)",
            "    return ld"
        ],
        "description": "Minimaler ROS2 Launch mit einem Argument und einem Node"
    },

    // üì¶ Basis-Importe f√ºr ROS2-Launch-Dateien
    "ROS2 Launch: Import Statements": {
        "prefix": "ros_launch_file_empty",
        "body": [
            "from launch import LaunchDescription",
            "from launch.actions import DeclareLaunchArgument",
            "from launch.substitutions import LaunchConfiguration",
            "from launch_ros.actions import Node",
            "from ament_index_python.packages import get_package_share_directory",
            "",
            "def generate_launch_description():",
            "    return ld"
        ],
        "description": "Importe f√ºr ROS2-Launch-Dateien"
    },
    
    // üß± Deklariert ein einzelnes Launch-Argument
    "ROS2 Launch: Declare Argument": {
        "prefix": "ros_launch_arg",
        "body": [
        "DeclareLaunchArgument(",
        "    '${1:arg_name}',",
        "    default_value='${2:default}',",
        "    description='${3:Beschreibung}'",
        ")"
        ],
        "description": "Deklariert ein Launch-Argument"
    },
    
    
    // ‚öôÔ∏è Node mit Parametern
    "ROS2 Launch: Node mit Parametern": {
        "prefix": "ros_launch_node_param",
        "body": [
        "Node(",
        "    package='${1:mein_paket}',",
        "    executable='${2:mein_knoten}',",
        "    name='${3:knoten_name}',",
        "    parameters=[{",
        "        '${4:param_name}': ${5:Wert}",
        "    }],",
        "    output='screen'",
        ")"
        ],
        "description": "ROS2 Node mit Parametern"
    },   

    "Include Launch Description": {
        "prefix": "ros_launch_ld",
        "body": [
        "ld_${1:name} = IncludeLaunchDescription(",
        "    PythonLaunchDescriptionSource([",
        "        os.path.join(",
        "            get_package_share_directory(\"${2:package_name}\"),",
        "            \"launch\",",
        "            \"${3:launch_file}.launch.py\"",
        "        )",
        "    ])",
        ")"
        ],
        "description": "Include a launch description with placeholders for package and launch file"
    },

    "CMakeLists: Include RIDL": {
        "prefix": "ros_cmake_ridl",
        "body": [
            "find_package(rosidl_default_generators REQUIRED)",
            "",
            "rosidl_generate_interfaces(\\${PROJECT_NAME}",
            "\"srv/MeinInterface.srv\"",
            ")",
            "",
            "ament_export_dependencies(rosidl_default_runtime)",
        ],
        "description": "Erweiterung in CMAKE zum Bauen von Interfaces mit RIDL"
    },

    "package_xml: Include RIDL": {
        "prefix": "ros_package_xml_ridl",
        "body": [
            "  <buildtool_depend>rosidl_default_generators</buildtool_depend>",
            "  <exec_depend>rosidl_default_runtime</exec_depend>",
            "  <member_of_group>rosidl_interface_packages</member_of_group>",
        ],
        "description": "Erweiterung in package.xml zum Bauen von Interfaces mit RIDL"
    },

    "ROS2 StateMachine Base": {
    "prefix": "ros_sm_base",
    "description": "Basisklassen State und StateMachine f√ºr ROS2-Zustandsautomat",
    "body": [
      "from __future__ import annotations",
      "from abc import ABC, abstractmethod",
      "",
      "",
      "class State(ABC):",
      "    \"\"\"Basisklasse f√ºr alle Zust√§nde der State-Machine.\"\"\"",
      "",
      "    def __init__(self, name: str) -> None:",
      "        self.name = name",
      "",
      "    def on_enter(self, node) -> None:",
      "        \"\"\"Wird einmalig beim Eintritt in den Zustand ausgef√ºhrt.\"\"\"",
      "        pass",
      "",
      "    def on_exit(self, node) -> None:",
      "        \"\"\"Wird einmalig beim Verlassen des Zustands ausgef√ºhrt.\"\"\"",
      "        pass",
      "",
      "    @abstractmethod",
      "    def tick(self, node) -> str | None:",
      "        \"\"\"",
      "        Wird zyklisch aufgerufen.",
      "        Muss entweder None (im Zustand bleiben)",
      "        oder den Namen des n√§chsten States zur√ºckgeben.",
      "        \"\"\"",
      "        ...",
      "",
      "",
      "class StateMachine:",
      "    \"\"\"Verwalten der States + Ablaufsteuerung.\"\"\"",
      "",
      "    def __init__(self, node) -> None:",
      "        self._node = node",
      "        self._states: dict[str, State] = {}",
      "        self._current_state: State | None = None",
      "",
      "    def add_state(self, state: State) -> None:",
      "        self._states[state.name] = state",
      "",
      "    def set_initial_state(self, name: str) -> None:",
      "        self._current_state = self._states[name]",
      "        self._node.get_logger().info(f\"Initialer Zustand: {name}\")",
      "        self._current_state.on_enter(self._node)",
      "",
      "    def step(self) -> None:",
      "        \"\"\"Soll aus dem ROS2-Timer aufgerufen werden.\"\"\"",
      "        if self._current_state is None:",
      "            return",
      "",
      "        next_name = self._current_state.tick(self._node)",
      "",
      "        if next_name is not None and next_name != self._current_state.name:",
      "            # Ausgangsaktion",
      "            self._current_state.on_exit(self._node)",
      "",
      "            old = self._current_state.name",
      "            self._current_state = self._states[next_name]",
      "",
      "            self._node.get_logger().info(",
      "                f\"Zustandswechsel: {old} ‚Üí {next_name}\"",
      "            )",
      "",
      "            # Eingangsaktion",
      "            self._current_state.on_enter(self._node)"
    ]
  },
  "ROS2 StateMachine State": {
    "prefix": "ros_sm_state",
    "description": "Vorlage f√ºr einen ROS2-State (Datei im states-Ordner)",
    "body": [
      "from __future__ import annotations",
      "# Den nachfolgenden Import eventuell anpassen!",
      "from ..state_machine import State",
      "",
      "",
      "class ${1:MyNewState}(State):",
      "    \"\"\"${2:Beschreibung des States}\"\"\"",
      "",
      "    def __init__(self) -> None:",
      "        super().__init__(\"${3:MY_NEW_STATE}\")",
      "",
      "    def on_enter(self, node) -> None:",
      "        node.get_logger().info(\"ENTER ${3:MY_NEW_STATE}\")",
      "",
      "    def tick(self, node) -> str | None:",
      "        node.get_logger().info(\"TICK ${3:MY_NEW_STATE}\")",
      "",
      "        # TODO: √úbergangsbedingung anpassen",
      "        if self._counter > 10:",
      "            return \"${4:NEXT_STATE}\"",
      "",
      "        return None",
      "",
      "    def on_exit(self, node) -> None:",
      "        node.get_logger().info(\"EXIT ${3:MY_NEW_STATE}\")"
    ]
  },
  "ROS2 Qt GUI Node": {
    "prefix": "ros_qt_gui_node",
    "description": "ROS2 Node + Qt GUI with spin thread (custom class names)",
    "body": [
      "import sys",
      "import threading",
      "",
      "import rclpy",
      "from rclpy.node import Node",
      "from rclpy.executors import SingleThreadedExecutor",
      "",
      "from PyQt5 import QtCore, QtGui, QtWidgets",
      "",
      "class ${1:MyROSNode}(Node):",
      "    def __init__(self, node_name: str):",
      "        super().__init__(node_name)",
      "",
      "    def destroy_node(self):",
      "        return super().destroy_node()",
      "",
      "",
      "class ${2:MyGUI}(QtWidgets.QWidget):",
      "    \"\"\"",
      "    Qt-GUI",
      "    \"\"\"",
      "",
      "    def __init__(self, node: ${1:MyROSNode}):",
      "        super().__init__()",
      "        self.node = node",
      "",
      "        self.setWindowTitle(\"Empty GUI\")",
      "        self.resize(400, 100)",
      "",
      "        self.btn_quit = QtWidgets.QPushButton(\"Beenden\")",
      "        self.btn_dummy = QtWidgets.QPushButton(\"Klick mich\")",
      "",
      "        layout_button = QtWidgets.QVBoxLayout()",
      "        layout_button.addWidget(self.btn_dummy)",
      "        layout_button.addWidget(self.btn_quit)",
      "",
      "        self.setLayout(layout_button)",
      "",
      "        self.btn_dummy.clicked.connect(self.on_dummy_clicked)",
      "        self.btn_quit.clicked.connect(self.close)",
      "",
      "    def on_dummy_clicked(self):",
      "        \"\"\"Dummy-Button gedr√ºckt.\"\"\"",
      "        self.node.get_logger().info(\"Dummy-Button gedr√ºckt!\")",
      "        msgbox = QtWidgets.QMessageBox(self)",
      "        msgbox.setWindowTitle(\"Dummy\")",
      "        msgbox.setText(\"Du hast mich geklickt!\")",
      "        msgbox.show()",
      "",
      "    def closeEvent(self, event):",
      "        if rclpy.ok():",
      "            self.node.get_logger().info(\"GUI wird geschlossen, ROS wird heruntergefahren...\")",
      "            rclpy.shutdown()",
      "        event.accept()",
      "",
      "",
      "def main():",
      "    node = None",
      "    executor = None",
      "    spin_thread = None",
      "",
      "    try:",
      "        rclpy.init()",
      "",
      "        node = ${1:MyROSNode}(\"${3:my_gui_node}\")",
      "        executor = SingleThreadedExecutor()",
      "        executor.add_node(node)",
      "",
      "        # Thread-Funktion f√ºr ROS-Spin",
      "        def ros_spin():",
      "            try:",
      "                executor.spin()",
      "            finally:",
      "                executor.shutdown()",
      "                node.destroy_node()",
      "",
      "        # Hintergrund-Thread starten",
      "        spin_thread = threading.Thread(target=ros_spin, daemon=True)",
      "        spin_thread.start()",
      "",
      "        # Qt-App im Hauptthread laufen lassen",
      "        app = QtWidgets.QApplication(sys.argv)",
      "        window = ${2:MyGUI}(node)",
      "        window.show()",
      "        exit_code = app.exec_()",
      "",
      "        # Wenn Qt beendet ‚Üí sicherstellen, dass ROS auch aus ist",
      "        if rclpy.ok():",
      "            rclpy.shutdown()",
      "",
      "        # Auf Thread warten (kurz)",
      "        if spin_thread.is_alive():",
      "            spin_thread.join(timeout=1.0)",
      "",
      "        sys.exit(exit_code)",
      "",
      "    except KeyboardInterrupt:",
      "        print(\"STRG+C gedr√ºckt\")",
      "        if rclpy.ok():",
      "            rclpy.shutdown()",
      "",
      "    finally:",
      "        if executor is not None:",
      "            executor.shutdown()",
      "        if node is not None:",
      "            try:",
      "                node.destroy_node()",
      "            except Exception:",
      "                pass",
      "        if rclpy.ok():",
      "            rclpy.shutdown()",
      "",
      "if __name__ == \"__main__\":",
      "    main()"
    ]
  },
  "Contour Moments Center": {
        "prefix": "cv_contour_center",
        "body": [
            "M = cv2.moments(${1:contour})",
            "if M['m00'] != 0:",
            "    cx = int(M['m10'] / M['m00'])",
            "    cy = int(M['m01'] / M['m00'])",
            "    ${2:# further processing}"
        ],
        "description": "Calculate centroid (cx, cy) from contour moments"
   },
   "Contour BoundingBox + Center": {
        "prefix": "cv_contour_center_box",
        "body": [
            "M = cv2.moments(${1:contour})",
            "if M['m00'] != 0:",
            "    cx = int(M['m10'] / M['m00'])",
            "    cy = int(M['m01'] / M['m00'])",
            "",
            "    # Bounding box",
            "    x, y, w, h = cv2.boundingRect(${1:contour})",
            "",
            "    # Draw bounding box",
            "    cv2.rectangle(${2:image}, (x, y), (x + w, y + h), (0, 255, 0), 2)",
            "",
            "    # Draw centroid",
            "    cv2.circle(${2:image}, (cx, cy), 5, (0, 0, 255), -1)",
            "",
        ],
        "description": "Draw bounding box and centroid from contour"
    },
    "Contour minAreaRect": {
        "prefix": "cv_minarearect_center",
        "body": [
            "rect = cv2.minAreaRect(${1:contour})  # smallest enclosing rotated rectangle",
            "(cx, cy), (width, height), angle = rect",
            "cx, cy = np.int0((cx, cy))",
            "",
        ],
        "description": "Get rotated bounding box (minAreaRect) parameters"
    },
    
    "Draw minAreaRect Box + Center + Angle": {
        "prefix": "cv_minarearect_center_box",
        "body": [
            "rect = cv2.minAreaRect(${1:contour})  # smallest enclosing rotated rectangle",
            "(cx, cy), (width, height), angle = rect",
            "cx, cy = np.int0((cx, cy))",
            "",
            "box = cv2.boxPoints(rect)  # convert to corner points",
            "box = np.int0(box)",
            "",
            "# Draw rotated bounding box",
            "cv2.drawContours(${2:frame}, [box], 0, (0, 0, 255), 2)",
            "",
            "# Draw centroid",
            "cv2.circle(${2:frame}, (cx, cy), 5, (255, 0, 0), -1)",
            "",
            "# Show angle text",
            "cv2.putText(",
            "    ${2:frame},",
            "    f\"Angle: {angle:.1f}\",",
            "    (cx + 10, cy - 10),",
            "    cv2.FONT_HERSHEY_SIMPLEX,",
            "    0.5,",
            "    (255, 0, 0),",
            "    2",
            ")",
            "",
        ],
        "description": "Draw rotated bounding box with centroid and angle text"
    },

    "KeyReader class (non-blocking stdin)": {
    "prefix": "keyreader",
    "description": "Non-blocking keyboard reader using termios/tty/select",
    "body": [
      "import os, sys, termios, tty, select, fcntl, time",
      "",
      "class KeyReader:",
      "    def __init__(self):",
      "        self.fd = sys.stdin.fileno()",
      "        self.old_term = termios.tcgetattr(self.fd)",
      "        self.old_flags = fcntl.fcntl(self.fd, fcntl.F_GETFL)",
      "",
      "    def __enter__(self):",
      "        tty.setraw(self.fd)",
      "",
      "        new = termios.tcgetattr(self.fd)",
      "        new[1] |= termios.OPOST | termios.ONLCR   # oflag: \\n -> \\r\\n",
      "        termios.tcsetattr(self.fd, termios.TCSADRAIN, new)",
      "",
      "        fcntl.fcntl(self.fd, fcntl.F_SETFL, self.old_flags | os.O_NONBLOCK)",
      "        return self",
      "",
      "    def __exit__(self, exc_type, exc, tb):",
      "        termios.tcsetattr(self.fd, termios.TCSADRAIN, self.old_term)",
      "        fcntl.fcntl(self.fd, fcntl.F_SETFL, self.old_flags)",
      "",
      "    def read_available(self) -> str:",
      "        buf = []",
      "        while True:",
      "            r, _, _ = select.select([sys.stdin], [], [], 0)",
      "            if not r:",
      "                break",
      "            try:",
      "                data = os.read(self.fd, 1024)",
      "                if not data:",
      "                    break",
      "                buf.append(data.decode(\"utf-8\", errors=\"ignore\"))",
      "            except BlockingIOError:",
      "                break",
      "        return \"\".join(buf)"
    ]
  }
}
